# 입실 체크 해주세요 !! 🥗
# intellij 및 visual studio code 켜두세요 !!

# 금일 수업
1. CRUD - back-front 연결 / CORS 처리     -> WebConfg.java
2. SpringBoot Security 적용하고 CRUD 연결 -> SecurityConfig.java
3. 근데 터져서 2 번으로 default 로그인 창 / CRUD 연결
4. OAuth2 연결
  - Google을 통해서 로그인을 할 것이기 때문에 인증 받는 과정

# 수업 시작
- build.gradle spring security 관련 주석 삭제 -> 코끼리 -> 실행
- 혹시 안되는 분들은 TodoRepository 부분에 `<Todo, Long>`이 빠져있을 수 있습니다.
```java
public interface TodoRepository extends CrudRepository<Todo, Long>
```
  - 그리고 실행해보세요.
  - http://localhost:8080 으로 접속하면 자동으로 endpoint로 /login이 적용되면서 로그인창이 defualt로 생깁니다.
  - user / 콘솔창에서 확인 가능

  - whitelabel page는 지금 신경쓰지 않겠습니다.

- src 내부에 config 패키지 생성 -> SecurityConfig.java 파일 생성 

```java
package com.example.todo_backend_mariadb.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;


import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        // corsConfigurationSource() 이거 밑에 정의하니까 빨갛게 뜨는거 정상입니다.
        http.cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authz ->
                        // preflight 요청(OPTION 메서드)은 인증 없이 모두 허용
                        authz.requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                                // 현재 로그인 기능이 따로 없으므로, 모든 API 요청을 임시로 허용
                                .requestMatchers("/api/**").permitAll()
                                // 혹시 몰라서 나머지 모든 요청도 일단 허용
                                .anyRequest().permitAll()
                );
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Cache-Control", "Content-Type"));
        configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```
  - 이상과 같이 작성 -> 근데 filterChain은 필수적으로 요구되기 때문에 복습 및 연구가 요구됩니다.

- application.properties 확인
  - 백엔드에서 데이터를 생성(POST)하거나 수정(PUT / PATCH)했을 때, 그 결과를 프론트엔드에게 알려주도록 설정. 만약에 이 부분이 빠지게되면 프론트엔드는 백에서 생성된 데이터의 id를 알 수 없기 때문에 이후에 충돌이 일어날 가능성이 있음.

```application.properties
spring.data.rest.return-body-on-create=true
spring.data.rest.return-body-on-update=true
```

- 이제 재시작을 했을 때 정상적으로 실행이 된다면 일단 모든 HTTP 메서드 요청에 대한 허용이 적용되어있는 백엔드가 작성됐다고 볼 수 있습니다.

- 그러면 수정된 백엔드를 기반으로 React 프로젝트를 백엔드와 연결하는 과정이 필요한데, 기존에 만들어 놨던(즉 프론트 상에서 구현이 되는 것을 확인했던) 부분들을 백엔드의 연결과 맞게 뜯어고쳐야합니다.

- 이상의 과정에서 느끼기 쉬운 부분이 -> 아니 결국 뜯어 고칠건데 왜 이렇게 짜놨냐 가 될 수 있는데, 구현 자체를 가능하게 만들어놓고 백과 연결하기 위해서라고 생각하시면 되겠습니다.

- 여러분이 익숙해지시면 애초에 백-프론트를 왔다갔다하면서 작업하시는 것도 가능할겁니다.

```tsx
import './App.css'
import { useState } from 'react';
import type { Todo } from './types/Todo';
import TodoForm from "./components/TodoForm"
import {TodoList} from "./components/TodoList"
import { v4 as uuid } from 'uuid';

function App() {
  const [ todos, setTodos ] = useState<Todo[]>(() => {
    const storedTodos = localStorage.getItem('todos');
    return storedTodos ? JSON.parse(storedTodos): [];
  });

  const addTodo = (text: string) => {
    const newTodo: Todo = {
      id: uuid(),
      text,
      completed: false,
    }
    const updatedTodos = [ ...todos, newTodo ];
    console.log('updatedTodos --->', updatedTodos);
    setTodos(updatedTodos);
    localStorage.setItem('todos', JSON.stringify(updatedTodos));
  }

  const deleteTodo = (id: string) => {
    const updatedTodos = todos.filter((todo) => todo.id !== id);
    setTodos(updatedTodos);
    localStorage.setItem('todos', JSON.stringify(updatedTodos));
  } 

  const toggleComplete = (id: string) => {
    const updatedTodos = todos.map((todo) => todo.id === id ? {...todo, completed: !todo.completed } : todo );
    setTodos(updatedTodos);
    localStorage.setItem('todos', JSON.stringify(updatedTodos));
  }

  return (
    <div>
      <h1>쇼핑 리스트</h1>
      <TodoForm onAddTodo={addTodo}/>
      <TodoList todos={todos} onToggleComplete={toggleComplete} onDeleteTodo={deleteTodo}/>
    </div>
  )
}

export default App
```

- 수정 전에 마지막으로 프론트 자체만으로 굴러가던 프론트를 그냥 복붙해놨습니다.

이제 수정할건데, 첫 번째 -> types.ts에서 id: number로 수정

- src 내부에 services 폴더 생성 -> todoService.ts 파일 생성

- 백-프론트 연결이 기준이 됩니다.
  - 백에서 정보를 받아와서 프론트에서 보여주거나,
  - 프론트에 입력한 정보를 백에 POST / PUT / PATCH / DELETE가 일어나야합니다.
  - 그럴 때 쓰는 패키지가 뭐였나요?
  - advanced-todo-app에서 터미널 열고 npm install axios